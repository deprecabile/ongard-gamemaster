# Ongard Gamemaster

An Open Source, AI-driven Game Master and Narrative Engine. Uses a Dual-Agent LLM architecture to generate cohesive, immersive text RPG adventures.

This project aims to provide a reliable, rule-abiding AI Game Master that enforces lore consistency and handles player inventory through a sophisticated multi-agent backend architecture, utilizing Retrieval-Augmented Generation (RAG) and (local) LLMs.

## ðŸš€ Features

*   **Dual-Agent LLM Architecture:** Utilizes two separate local Ollama instances to optimize hardware resources:
    *   **GPU Instance:** Runs the creative Game Master model (e.g., Llama 3.1 8B) for high-quality narrative generation.
    *   **CPU Instance:** Runs lightweight models (e.g., Qwen3 4B) for deterministic tasks like semantic routing, lore reviewing with constrained decoding (Structured Output), and inventory management.
*   **Multi-Agent Validation Pipeline:** Every scene generated by the Game Master is internally routed and validated in parallel by specialized "Reviewer Agents" (checking magic rules, economy, world lore) and an "Inventory Validator". The scene is only shown to the player if it passes all checks.
*   **Automated Retry Policy:** If a reviewer detects an inconsistency, the backend automatically instructs the Game Master to rewrite the scene, fixing the specific logical errors before presenting it to the user.
*   **Robust Session Management:** Uses Redis for fast, caching-based `PlayerContext` management with a write-behind strategy to PostgreSQL for permanent storage.
*   **Server-Sent Events (SSE):** Provides real-time streaming updates to the frontend about the AI's "thought process" (e.g., "The Game Master is writing...", "Validating lore...") to enhance UX during generation times.

## ðŸ› ï¸ Technology Stack

*   **Backend:** Java 25, Spring Boot 4.0.2, Spring AI, Lombok
*   **Frontend:** React, TypeScript, SCSS
*   **AI Engine:** Local Ollama (Dual Instance via Docker Compose)
*   **Database:** PostgreSQL (with Liquibase for migrations)
*   **Cache / Session:** Redis (Event-driven expiration)

## ðŸ—ï¸ Architecture Architecture Overview

The system strictly separates the narrative context (Lore) from the business logic. Rules and world-building are stored in Markdown files and injected via RAG. The Java application remains completely agnostic to the specific game setting.

The core flow follows a **Draft -> Validate -> Publish** pattern:
1.  **Pre-Gen (RAG):** User action + current scene info retrieves relevant lore.
2.  **Draft:** The Game Master agent generates a draft scene.
3.  **Routing:** A Router agent determines the themes of the draft (e.g., MAGIC, ECONOMY).
4.  **Validation:** Specialized Reviewer agents and an Inventory validator analyze the draft in parallel.
5.  **Publish:** If all checks pass, the scene is saved and sent to the client. If not, the GM is prompted to correct the errors (up to a maximum number of retries).

## ðŸ“„ License

This project is licensed under the **GNU Affero General Public License v3.0 (AGPLv3)** - see the [LICENSE](LICENSE) file for details.

### Commercial Use
If you wish to use this engine for commercial purposes without the strict copyleft obligations of the AGPLv3 (e.g., keeping your modifications and infrastructure proprietary, or offering it as a closed SaaS), please contact me to arrange a commercial license.
